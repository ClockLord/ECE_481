

----------------------------------------------------------------------------------
-- Company:
-- Engineer:
--
-- Create Date: 11/12/2023 07:51:55 PM
-- Design Name:
-- Module Name: WaveGen - Behavioral
-- Project Name:
-- Target Devices:
-- Tool Versions:
-- Description:
--
-- Dependencies:
--
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

--Create a component that is the DAC controller
--Based on what switch is pressed
--give the DAC controller the correct LUT
    -- in order to do that you will need to make a counter


entity WaveGen is
  Port (
    Switch : in std_logic_vector (1 downto 0);
    iCLK : in  STD_LOGIC;
    iRESET : IN  std_logic;
    iEN_DAC : IN  std_logic;
    oSYNC_L : OUT  std_logic;
    oSDATA_DAC : OUT  std_logic;
    oDONE_DAC : OUT  std_logic;
    oBUSY_DAC : OUT  std_logic;
    DivClk : Out std_logic  
  );
end WaveGen;

architecture Behavioral of WaveGen is

COMPONENT DAC_controller
    PORT(
         iRESET : IN  std_logic;
         iCLK : IN  std_logic;
         iEN_DAC : IN  std_logic;
         iDAC_DATA_V : IN  std_logic_vector(11 downto 0);
         oSYNC_L : OUT  std_logic;
         oSDATA_DAC : OUT  std_logic;
         oDONE_DAC : OUT  std_logic;
         oBUSY_DAC : OUT  std_logic
        );
    END COMPONENT;
   
constant Resolution : INTEGER := 99;

type LUT is array (0 to Resolution) of std_logic_vector(11 downto 0);
--type TUL is array (0 to 99) of std_logic_vector(11 downto 0);
constant sine_table: LUT := (
    "111111111111", "111111111011", "111111101111", "111111011011",
    "111110111111", "111110011011", "111101101111", "111100111100",
    "111100000010", "111011000000", "111001111000", "111000101001",
    "110111010100", "110101111001", "110100011001",
    "110010110011", "110001001001", "101111011010", "101101100111",
    "101011110001", "101001111000", "100111111101", "100101111111",
    "100100000000", "100010000000", "100000000000", "011101111111",
    "011011111111", "011010000000", "011000000010", "010110000111",
    "010100001110", "010010011000", "010000100101", "001110110110",
    "001101001100", "001011100110", "001010000110", "001000101011",
    "000111010110", "000110000111", "000100111111", "000011111101",
    "000011000011", "000010010000", "000001100100", "000001000000",
    "000000100100", "000000010000", "000000000100", "000000000000",
    "000000000100", "000000010000", "000000100100", "000001000000",
    "000001100100", "000010010000", "000011000011", "000011111101",
    "000100111111", "000110000111", "000111010110", "001000101011",
    "001010000110", "001011100110", "001101001100", "001110110110",
    "010000100101", "010010011000", "010100001110", "010110000111",
    "011000000010", "011010000000", "011011111111", "011101111111",
    "011111111111", "100010000000", "100100000000", "100101111111",
    "100111111101", "101001111000", "101011110001", "101101100111",
    "101111011010", "110001001001", "110010110011", "110100011001",
    "110101111001", "110111010100", "111000101001", "111001111000",
    "111011000000", "111100000010", "111100111100", "111101101111",
    "111110011011", "111110111111", "111111011011", "111111101111",
    "111111111011"
);
constant triangle_table: LUT := (
    "000000000000", "001010101010", "010101010101", "011111111111",
    "101010101010", "110101010101", "111111111111", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000",
    "011111111111", "010101010101", "001010101010", "000000000000",
    "111111111111", "110101010101", "101010101010", "100000000000"
    
);

constant sawtooth_table: LUT := (
       
    "000000000000",
    "000000001010",
    "000000010100",
    "000000011110",
    "000000101000",
    "000000110010",
    "000000111100",
    "000001000110",
    "000001010000",
    "000001011010",
    "000001100100",
    "000001101110",
    "000001111000",
    "000010000010",
    "000010001100",
    "000010010110",
    "000010100000",
    "000010101010",
    "000010110100",
    "000010111110",
    "000011001000",
    "000011010010",
    "000011011100",
    "000011100110",
    "000011110000",
    "000011111010",
    "000100000100",
    "000100001110",
    "000100011000",
    "000100100010",
    "000100101100",
    "000100110110",
    "000101000000",
    "000101001010",
    "000101010100",
    "000101011110",
    "000101101000",
    "000101110010",
    "000101111100",
    "000110000110",
    "000110010000",
    "000110011010",
    "000110100100",
    "000110101110",
    "000110111000",
    "000111000010",
    "000111001100",
    "000111010110",
    "000111100000",
    "000111101010",
    "000111110100",
    "000111111110",
    "001000001000",
    "001000010010",
    "001000011100",
    "001000100110",
    "001000110000",
    "001000111010",
    "001001000100",
    "001001001110",
    "001001011000",
    "001001100010",
    "001001101100",
    "001001110110",
    "001010000000",
    "001010001010",
    "001010010100",
    "001010011110",
    "001010101000",
    "001010110010",
    "001010111100",
    "001011000110",
    "001011010000",
    "001011011010",
    "001011100100",
    "001011101110",
    "001011111000",
    "001100000010",
    "001100001100",
    "001100010110",
    "001100100000",
    "001100101010",
    "001100110100",
    "001100111110",
    "001101001000",
    "001101010010",
    "001101011100",
    "001101100110",
    "001101110000",
    "001101111010",
    "001110000100",
    "001110001110",
    "001110011000",
    "001110100010",
    "001110101100",
    "001110110110",
    "001111000000",
    "001111001010",
    "001111010100",
    "000000000000"
    
    
    
    );
constant rectangular_table: LUT := (
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111",
    "111111111111", "001111111111", "001111111111", "001111111111"
);

signal DAC_DATA_Buff : STD_LOGIC_VECTOR (11 downto 0);    --signal to store the values that we pass to the controller
signal ClkDiv : std_logic := '0'; --clkDivided signal
signal ClkDivMax : INTEGER := 1; 
signal ClkCount : INTEGER := 0;
signal BuffCount : integer :=0;

signal DONE_DAC_temp, done_dac_reg : std_logic := '0';

begin
 WaveGen_cntrl: DAC_controller PORT MAP (
      iRESET => iRESET,
      iCLK => ClkDiv, --DAC works at maximum 30M clock
      iEN_DAC => iEN_DAC,
      iDAC_DATA_V => DAC_DATA_Buff, --pass the controller data from the buffer
      oSYNC_L => oSYNC_L,
      oSDATA_DAC => oSDATA_DAC,
      oDONE_DAC => DONE_DAC_temp,
      oBUSY_DAC => oBUSY_DAC    
        );
        
        
oDONE_DAC <= DONE_DAC_temp;--temporary variable to store output of the Done Flag

CLK_Divider:process(iCLK, iRESET,ClkDiv) --implement clk divider circuit for the ADC needs 30Mhz clk
  variable int_count : integer range 0 to 100 := 0;
  begin
    if rising_edge(iCLK) then
        ClkCount <= ClkCount +1;
            if ClkCount >= ClkDivMax then --what triggers during the falling edge of clkDiv
                clkCount <= 0;
                ClkDiv <= not ClkDiv;
                DivClk <= ClkDiv; --just for simulation purposes
            end if;  
    end if;
    
    if rising_edge(ClkDiv) then --implement counter to go through LUT
      if (int_count = 100) then 
          int_count := 0;
          BuffCount <= BuffCount +1;
      else
         int_count := int_count + 1;
          BuffCount <= BuffCount;
      end if;
    
     
       
        
        
            if BuffCount >= Resolution then --loop througn
                BuffCount <=0;
            end if;
    end if;
end process;

WaveSelect: process(iclk)   --select a waveform based on input from a switch
 
begin
  if rising_edge(iclk) then
   
   done_dac_reg <= done_dac_temp;
   
    if Switch = "00" then   -- Sin Wave
      if done_dac_reg = '0' and DONE_DAC_temp = '1' then
        DAC_DATA_Buff <= sine_table(BuffCount);
      end if;
      
    elsif Switch = "01" then -- Triangle Wave
      if done_dac_reg = '0' and DONE_DAC_temp = '1' then
        DAC_DATA_Buff <= triangle_table(BuffCount);
      end if;
      
    elsif Switch = "10" then -- Sawtooth Wave
      if done_dac_reg = '0' and DONE_DAC_temp = '1' then
        DAC_DATA_Buff <= sawtooth_table(BuffCount);
      end if;
      
    elsif Switch = "11" then -- Rectangular Wave
       if done_dac_reg = '0' and DONE_DAC_temp = '1' then
        DAC_DATA_Buff <= rectangular_table(BuffCount);
      end if;
    end if;
    
  end if;
end process;

end Behavioral;